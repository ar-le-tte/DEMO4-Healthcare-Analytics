Part 3.3 – Star Schema Queries (star_schema_queries.txt)
=======================================================

QUERY 1: Monthly Encounters by Specialty
------------------------------------------------------------
SQL Query:
SELECT d.year, d.month_number, d.month_name, s.specialty_name, et.encounter_type_name,
  COUNT(*) AS total_encounters,
  COUNT(DISTINCT f.patient_key) AS unique_patients
FROM fact_encounters f
JOIN dim_date d ON d.date_key = f.encounter_date_key
JOIN dim_specialty s ON s.specialty_key = f.specialty_key
JOIN dim_encounter_type et ON et.encounter_type_key = f.encounter_type_key
GROUP BY
  d.year, d.month_number, d.month_name, s.specialty_name, et.encounter_type_name
ORDER BY
  d.year, d.month_number, s.specialty_name, et.encounter_type_name;

Execution time estimate:
- Star schema: 11.009 ms
- OLTP schema: 32.795 ms

Improvement factor:
32.795 / 11.009 ≈ 2.98x faster

Why it’s faster:
- The fact table already contains the specialty_key and encounter_type_key, so we avoid the OLTP join chain encounters → providers → specialties.
- The added composite index on fact_encounters helps the planner handle grouping and the COUNT(DISTINCT patient_key) more efficiently, so less time is spent in the sort + aggregate phase.
- Joins are against small dimensions (25 specialties, 3 encounter types, ~731 dates) using integer keys, which keeps hash joins cheap.
- The main remaining cost is COUNT(DISTINCT ...) which still forces a sort, but the overall join work is reduced compared to OLTP.

QUERY 2: Top Diagnosis–Procedure Pairs
------------------------------------------------------------
SQL Query:
SELECT d.icd10_code, p.cpt_code, fp.encounter_count
FROM fact_diag_proc_pairs fp
JOIN dim_diagnosis d ON d.diagnosis_key = fp.diagnosis_key
JOIN dim_procedure p ON p.procedure_key = fp.procedure_key
ORDER BY fp.encounter_count DESC
LIMIT 20;

Execution time estimate:
- Star schema (with a pre-aggregated pairs table): 0.180 ms
- OLTP schema: 38.073 ms

Improvement factor:
38.073 / 0.180 ≈ 211.5x faster

Why it’s faster:
- Instead of joining two junction/bridge tables at query time (which creates a diagnosis_count × procedure_count row explosion per encounter), we precompute the diagnosis–procedure pair counts once into star.fact_diag_proc_pairs.
- The query becomes a simple lookup + small joins to two dimensions (dim_diagnosis and dim_procedure), followed by an ORDER BY on an already computed metric.
- This removes the expensive join-and-group work from the query path and makes performance essentially constant-time for reporting.

QUERY 3: 30-Day Readmission Rate by Specialty
------------------------------------------------------------
SQL Query:
WITH inpatient AS (SELECT f.encounter_id, f.patient_key, f.specialty_key, f.discharge_date_key, dc.date_key AS cutoff_date_key
  FROM star.fact_encounters f
  JOIN star.dim_encounter_type et ON et.encounter_type_key = f.encounter_type_key
  JOIN star.dim_date dd ON dd.date_key = f.discharge_date_key
  JOIN star.dim_date dc ON dc.calendar_date = dd.calendar_date + INTERVAL '30 days'
  WHERE et.encounter_type_name = 'Inpatient'
    AND f.discharge_date_key IS NOT NULL),
next_within_30 AS (SELECT i.encounter_id, i.specialty_key, (nxt.fact_encounter_key IS NOT NULL) AS is_readmitted
  FROM inpatient i
  LEFT JOIN LATERAL (
    SELECT f2.fact_encounter_key
    FROM star.fact_encounters f2
    WHERE f2.patient_key = i.patient_key
      AND f2.encounter_date_key > i.discharge_date_key
      AND f2.encounter_date_key <= i.cutoff_date_key
    ORDER BY f2.encounter_date_key
    LIMIT 1) nxt ON TRUE)
SELECT s.specialty_name, COUNT(*) FILTER (WHERE is_readmitted) AS readmissions, COUNT(*) AS inpatient_discharges,
  ROUND(COUNT(*) FILTER (WHERE is_readmitted)::numeric / NULLIF(COUNT(*),0), 4) AS readmission_rate
FROM next_within_30 r
JOIN star.dim_specialty s ON s.specialty_key = r.specialty_key
GROUP BY s.specialty_name
ORDER BY readmission_rate DESC;

Execution time estimate:
- Star schema (optimized): 6.867 ms
- OLTP schema: 42.317 ms

Improvement factor:
42.317 / 6.867 ≈ 6.164x faster

Why it’s faster:
- The OLTP approach needs a heavy self-join on encounters plus a join chain to providers/specialties.
- In the star schema, the keys needed for readmission (patient_key, specialty_key, discharge_date_key, encounter_date_key) are already in the fact table.
- The LATERAL subquery finds only the first qualifying next encounter per inpatient discharge (within 30 days), avoiding the inpatient × all-encounters row explosion.
- Index support on (patient_key, encounter_date_key) makes the per-patient lookup efficient, so we don’t generate millions of candidate rows.
QUERY 4: Revenue by Specialty & Month (Star Schema)
------------------------------------------------------------
SQL Query:
SELECT d.year, d.month_number, d.month_name, s.specialty_name, SUM(f.total_allowed_amount) AS total_allowed_amount
FROM star.fact_encounters f
JOIN star.dim_date d ON d.date_key = f.encounter_date_key
JOIN star.dim_specialty s ON s.specialty_key = f.specialty_key
WHERE f.has_billing = TRUE
GROUP BY d.year, d.month_number, d.month_name, s.specialty_name
ORDER BY d.year, d.month_number, total_allowed_amount DESC;

Execution time estimate:
- Star schema: 5.902 ms
- OLTP schema: 63.070 ms

Improvement factor:
63.070 / 5.902 ≈ 10.69x faster

Why it’s faster:
- In the star schema, billing revenue is already stored in the fact table as total_allowed_amount, so no billing → encounters → providers → specialties join chain is needed.
- The query only joins the fact table to small dimensions (date + specialty) and then aggregates.
- This eliminates expensive OLTP-style join-and-aggregate work and reduces intermediate row sizes, so the GROUP BY runs much faster.
