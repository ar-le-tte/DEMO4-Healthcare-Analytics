QUESTION 1: Monthly Encounters by Specialty
For each month and specialty, show total encounters and unique patients by encounter type.

SQL Query:
SELECT date_trunc('month', e.encounter_date)::date AS month_start, s.specialty_name,
  e.encounter_type, COUNT(*) AS total_encounters, COUNT(DISTINCT e.patient_id) AS unique_patients
FROM encounters e
JOIN providers p   ON p.provider_id = e.provider_id
JOIN specialties s ON s.specialty_id = p.specialty_id
GROUP BY date_trunc('month', e.encounter_date)::date, s.specialty_name, e.encounter_type
ORDER BY month_start, s.specialty_name, e.encounter_type;

Schema Analysis:
Tables joined: encounters, providers, specialties  
Number of joins: 2

Performance:
Execution time: 32.795 ms
Estimated rows scanned (approx): 30,000 rows in sequential scans
- encounters: 10,000 rows 
- providers: 10,000 rows 
- specialties: 10,000 rows 

Bottleneck Identified:
The query is slower at scale because specialty information is not stored in the encounters table, so the database must first execute a join chain
(encounters → providers → specialties) before performing the aggregation.
The execution plan shows two Hash Joins, followed by a Sort and GroupAggregate.
The COUNT(DISTINCT patient_id) forces additional work (the Sort includes patient_id), and the GROUP BY is on a computed month key (date_trunc),
which increases sorting/aggregation cost. In a normalized OLTP schema, this join-then-aggregate pattern creates large intermediate results and
makes monthly reporting queries more expensive as data grows.

QUESTION 2: Top Diagnosis-Procedure Pairs
What are the most common diagnosis-procedure combinations? Show the ICD code, procedure code, and encounter count.

SQL Query:
SELECT d.icd10_code, p.cpt_code, COUNT(DISTINCT ed.encounter_id) AS encounter_count
FROM encounter_diagnoses ed
JOIN diagnoses d ON d.diagnosis_id = ed.diagnosis_id
JOIN encounter_procedures ep ON ep.encounter_id = ed.encounter_id
JOIN procedures p ON p.procedure_id = ep.procedure_id
GROUP BY d.icd10_code, p.cpt_code
ORDER BY encounter_count DESC
LIMIT 20;

Schema Analysis:
Tables joined: encounter_diagnoses, diagnoses, encounter_procedures, procedures
Number of joins: 3
Join logic across junction tables:
- Diagnosis side: encounter_diagnoses → diagnoses (ed.diagnosis_id = d.diagnosis_id)
- Procedure side: encounter_procedures → procedures (ep.procedure_id = p.procedure_id)
- Bridge between them: ed.encounter_id = ep.encounter_id

Performance:
Execution time: 38.073 ms
Estimated/actual rows scanned (base table scans): 40,000 rows:
- encounter_diagnoses: 10,000 rows 
- diagnoses: 10,000 rows 
- encounter_procedures: 10,000 rows 
- procedures: 10,000 rows

Rows produced after joining diagnosis+procedure sides: 10,166 rows
Rows aggregated (groups produced): 10,166 groups
Result rows returned (LIMIT): 20
Key plan operators: Hash Join → Sort → GroupAggregate → Sort (top-N) → Limit

Bottleneck Identified:
This query is slow at scale because diagnosis and procedure data live in two separate many-to-many junction tables.
To create diagnosis–procedure pairs, the query must join encounter_diagnoses and encounter_procedures on encounter_id, which can cause row explosion:
if an encounter has D diagnoses and P procedures, the intermediate join can generate D×P rows for that encounter.
After this expansion, PostgreSQL must Sort and GroupAggregate to compute COUNT(DISTINCT encounter_id) per (icd10_code, cpt_code), which is expensive on large intermediate results.
Even though the final output is only 20 rows (LIMIT), the database still has to process and aggregate the full join result before it can return the top pairs.

QUESTION 3: 30-Day Readmission Rate
Definition used: an inpatient discharge followed by ANY subsequent encounter for the same patient within 30 days after discharge.

SQL Query:
SELECT s.specialty_name, COUNT(DISTINCT e1.encounter_id) AS inpatient_discharges,
  COUNT(DISTINCT CASE WHEN e2.encounter_id IS NOT NULL THEN e1.encounter_id END) AS readmitted_in_30d,
  ROUND(COUNT(DISTINCT CASE WHEN e2.encounter_id IS NOT NULL THEN e1.encounter_id END)::numeric / NULLIF(COUNT(DISTINCT e1.encounter_id), 0), 4)
    AS readmission_rate
FROM encounters e1
JOIN providers p1 ON p1.provider_id = e1.provider_id
JOIN specialties s ON s.specialty_id = p1.specialty_id
LEFT JOIN encounters e2 ON e2.patient_id = e1.patient_id
 AND e2.encounter_date > e1.discharge_date
 AND e2.encounter_date <= e1.discharge_date + INTERVAL '30 days'
WHERE e1.encounter_type = 'Inpatient'
GROUP BY s.specialty_name
ORDER BY readmission_rate DESC;

Schema Analysis:
Tables joined: encounters (e1), encounters (e2 self-join), providers, specialties
Number of joins: 3 total (including 1 self-join on encounters)
Readmission detection logic:
- Filter index admissions: e1.encounter_type = 'Inpatient'
- Match later visits for same patient: e2.patient_id = e1.patient_id
- Keep only encounters within 30 days after discharge:
  e2.encounter_date > e1.discharge_date AND e2.encounter_date <= e1.discharge_date + 30 days

Performance:
Execution time: 42.317 ms
Estimated/actual rows scanned (base table sequential scans): 40,000 rows:
- encounters e1: 10,000 rows scanned; 5,076 kept (Inpatient), 4,924 removed by filter
- encounters e2: 10,000 
- providers p1: 10,000 
- specialties s: 10,000 

Join characteristics:
- Self-join used a Hash Right Join on patient_id with an additional date-range join filter
- Rows removed by join filter (date window): 9,993
Result rows returned: 3,230 specialties (groups)

Bottleneck Identified:
This query becomes slow at scale primarily because it requires a self-join on the encounters table plus a date-range condition.
PostgreSQL must first match encounters by patient_id (hash join) and then apply the 30-day window filter using encounter_date and discharge_date,
which removes many candidate matches (9,993 rows removed by the join filter in this run) but still requires processing them.
After the self-join, the query performs aggregation with DISTINCT counts per specialty and then sorts again to rank specialties by readmission_rate.
In a normalized OLTP schema, additional joins (encounters → providers → specialties) are needed to attribute encounters to specialty, increasing overall work.

QUESTION 4: Revenue by Specialty & Month
Which specialties generate most revenue?

SQL Query:
SELECT date_trunc('month', b.claim_date)::date AS month_start, s.specialty_name, SUM(b.allowed_amount) AS total_allowed_amount
FROM billing b
JOIN encounters e ON e.encounter_id = b.encounter_id
JOIN providers p ON p.provider_id = e.provider_id
JOIN specialties s ON s.specialty_id = p.specialty_id
GROUP BY date_trunc('month', b.claim_date)::date, s.specialty_name
ORDER BY month_start, total_allowed_amount DESC;

Schema Analysis:
Tables joined: billing, encounters, providers, specialties
Number of joins: 3
JOIN chain: billing → encounters → providers → specialties

Performance:
Execution time: 63.070 ms
Estimated/actual rows scanned (base table scans): 40,000 rows sequentially scanned.
- billing: 10,000 rows 
- encounters: 10,000 rows 
- providers: 10,000 rows 
- specialties: 10,000 rows

Rows processed after joins: 10,000 rows
Groups produced (month_start, specialty): 9,371
Key plan operators: Hash Join → Hash Join → Hash Join → HashAggregate → Sort

Bottleneck Identified:
This query is slow because revenue is stored in billing while specialty is only available through encounters → providers → specialties,
so PostgreSQL must execute multiple joins before it can aggregate revenue.
The plan shows a chain of three Hash Joins followed by a HashAggregate to compute SUM(allowed_amount) by month and specialty.
Because month_start is a computed key (date_trunc on claim_date), the query must also Sort the aggregated results to satisfy the ORDER BY.
In a normalized OLTP schema, this multi-join + aggregation pattern is expensive for reporting workloads, and it grows more costly as billing and encounter volumes increase.
