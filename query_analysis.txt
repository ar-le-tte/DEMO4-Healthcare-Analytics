QUESTION 1: Monthly Encounters by Specialty

SQL Query:
SELECT
  date_trunc('month', e.encounter_date)::date AS month_start,
  s.specialty_name,
  e.encounter_type,
  COUNT(*) AS total_encounters,
  COUNT(DISTINCT e.patient_id) AS unique_patients
FROM encounters e
JOIN providers p   ON p.provider_id = e.provider_id
JOIN specialties s ON s.specialty_id = p.specialty_id
GROUP BY
  date_trunc('month', e.encounter_date)::date,
  s.specialty_name,
  e.encounter_type
ORDER BY
  month_start, s.specialty_name, e.encounter_type;

Schema Analysis:
Tables joined: encounters, providers, specialties  
Number of joins: 2

Performance:
Execution time: 32.795 ms
Estimated rows scanned (approx): 30,000 rows in sequential scans
- encounters: 10,000 rows 
- providers: 10,000 rows 
- specialties: 10,000 rows 

Bottleneck Identified:
The query is slower at scale because specialty information is not stored in the encounters table, so the database must first execute a join chain
(encounters → providers → specialties) before performing the aggregation.
The execution plan shows two Hash Joins, followed by a Sort and GroupAggregate.
The COUNT(DISTINCT patient_id) forces additional work (the Sort includes patient_id), and the GROUP BY is on a computed month key (date_trunc),
which increases sorting/aggregation cost. In a normalized OLTP schema, this join-then-aggregate pattern creates large intermediate results and
makes monthly reporting queries more expensive as data grows.

QUESTION 2: Top Diagnosis-Procedure Pairs

SQL Query:
SELECT
  d.icd10_code,
  p.cpt_code,
  COUNT(DISTINCT ed.encounter_id) AS encounter_count
FROM encounter_diagnoses ed
JOIN diagnoses d
  ON d.diagnosis_id = ed.diagnosis_id
JOIN encounter_procedures ep
  ON ep.encounter_id = ed.encounter_id
JOIN procedures p
  ON p.procedure_id = ep.procedure_id
GROUP BY d.icd10_code, p.cpt_code
ORDER BY encounter_count DESC
LIMIT 20;

Schema Analysis:
Tables joined: encounter_diagnoses, diagnoses, encounter_procedures, procedures
Number of joins: 3
Join logic across junction tables:
- Diagnosis side: encounter_diagnoses → diagnoses (ed.diagnosis_id = d.diagnosis_id)
- Procedure side: encounter_procedures → procedures (ep.procedure_id = p.procedure_id)
- Bridge between them: ed.encounter_id = ep.encounter_id

Performance:
Execution time: 38.073 ms
Estimated/actual rows scanned (base table scans): 40,000 rows
- encounter_diagnoses: 10,000 rows 
- diagnoses: 10,000 rows 
- encounter_procedures: 10,000 rows 
- procedures: 10,000 rows

Rows produced after joining diagnosis+procedure sides: 10,166 rows
Rows aggregated (groups produced): 10,166 groups
Result rows returned (LIMIT): 20
Key plan operators: Hash Join → Sort → GroupAggregate → Sort (top-N) → Limit

Bottleneck Identified:
This query is slow at scale because diagnosis and procedure data live in two separate many-to-many junction tables.
To create diagnosis–procedure pairs, the query must join encounter_diagnoses and encounter_procedures on encounter_id, which can cause row explosion:
if an encounter has D diagnoses and P procedures, the intermediate join can generate D×P rows for that encounter.
After this expansion, PostgreSQL must Sort and GroupAggregate to compute COUNT(DISTINCT encounter_id) per (icd10_code, cpt_code), which is expensive on large intermediate results.
Even though the final output is only 20 rows (LIMIT), the database still has to process and aggregate the full join result before it can return the top pairs.
